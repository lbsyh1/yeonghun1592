### 1.

``` 

let a : unknown;//변수의 타입을 미리 알지 못할때 사용

if(typeof a ==='number'){
  let b =a+1 //if문 없으면 a가 unknown이라 에러
}

```

### 2. void함수
아무것도 return하지 않는 함수 대상
예를들어

```

function hello(){
  console.log('x')
}

```

### 3.never함수
//절대 return 하지 않는 함수

```
  
  function hello():never{
    throw new Error("xxx")
  }
  
```

```

  function hello(name:string|number){
    if(typeof name === "string"){
      name  //string
    } else if (typeof name === "number"){
      name  //number
    } else {
      name  //이미 string과 number가 나왔기 때문에 코드가 위에서 이미 실행되어 이 라인은 절대 실행되면 안된다never
    }
    
```

### 4. 

```
  
  function add(a:number, b:number){
    return a+b;
  }
  
  const add= (a:number,b:number)=>a+b;
  
```

call signature함수위에 마우스를 올렸을때 보이는 것

call signatures란 함수 이름 위에 커서를 올렸을 때 뜨는 파라미터 타입 정보와 리턴 타입 정보를 말한다.
함수를 어떻게 호출해야 하는지와 반환이 어떻게 되는지 알려주는 정보

call signature로 개발자가 직접 타입을 만들 수 있고, 함수가 어떻게 동작하는지 서술해둘 수 있다

장점1. 먼저 함수의 타입을 설명하고 나서 코드를 구현하게 되기 때문에, 개발자가 타입을 생각하도록 해준다.

함수 파라미터 안에서 직접 타입을 설정할 때엔 코드 구현과 동시에 타입을 지정했지만, call signature를 쓰면 타입 지정과 함수 구현을 분리해서 작성할 수 있다.
```

type Add = (a:number, b:number)=>number;

const add:Add = (a,b) => a+b;

```

### 5. 오버로딩
함수가 여러개의 call signature를 가졌을때 발생한다

```

type Add = {
  (a: number, b: number) : number
  (a: number, b: string) : number
}

const add:Add=(a,b)=>{
  if(typeof b==="string") return a
  return a+b
}

```

```

type Config ={
  path:string,
  state:object

type Push = {
  (path:string):void
  (config:Config):void
}

cosnt push: Push=(config)=>{
  if(typeof config ==="string") console.log(config)
  else {
    console.log(config.path)
  }
}
